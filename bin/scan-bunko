#!/usr/bin/env ruby

# usage:
#
# 1. set bunko as landscape
# 2. run scan-bunko

# set the first page (front face) bottom 
# landscape

require 'optparse'
require 'json'
require 'open3'

op = OptionParser.new
$opt_d = '.'
op.def_option('-h', '--help', 'show help message') { puts op; exit 0 }
op.def_option('-d DIR', '--destination-directory DIR', 'destination directory') {|arg| $opt_d = arg }
op.parse(ARGV)

outdir = $opt_d
unless File.directory? outdir
  Dir.mkdir outdir
end

nums = Dir.entries(outdir).reject {|f|
  /\Aout([0-9]+)\.pnm\z/ !~ f
}.map {|f| f[/\d+/].to_i }
if nums.empty?
  start = 0
else
  start = nums.max + 1
end

resolution_dpi = 300 # dot per inch
system(
  "scanimage",
  "--batch=#{outdir}/out%04d.pnm",
  "--batch-start=#{start}",
  "--source", "ADF Duplex",
  "--mode", "Color",
  "--resolution", resolution_dpi.to_s,
  "-l", "30",
  "-x", "160",
  "--ald=yes")

scan_json_path = "#{outdir}/scan.json"
if File.exist? scan_json_path
  index_hash = File.open(scan_json_path) {|f| JSON.load(f) }
else
  index_hash = {}
end

fs = Dir.entries(outdir).reject {|f| /\Aout([0-9]+)\.pnm\z/ !~ f }
fs = fs.sort_by {|f| f[/\d+/].to_i }

fs.each {|f|
  n = f[/\d+/].to_i
  next if n < start
  index_hash["s"] ||= {}
  index_hash["s"][f] = { "dpi_x" => resolution_dpi,
                         "dpi_y" => resolution_dpi }
  f2 = f.sub(/\Aout/, 'fullsize').sub(/\.pnm\z/, '.png')
  angle = (n-start) % 2 == 0 ? "ccw" : "cw"
  index_hash["i"] ||= {}
  index_hash["i"][f2] = ["convert", "png",
                          ["flip", angle,
                            ["resolution", resolution_dpi,
                              ["make", f]]]]
  index_hash["list"] ||= []
  index_hash["list"] << f2
}

tmp_scan_json_path = scan_json_path + '.part'
File.open(tmp_scan_json_path, 'w') {|f|
  f.puts JSON.pretty_generate(index_hash)
}
File.rename tmp_scan_json_path, scan_json_path
