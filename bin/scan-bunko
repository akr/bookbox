#!/usr/bin/env ruby

# usage:
#
# 1. set bunko as landscape
# 2. scan-bunko

# set first page (front face) bottom 
# landscape

require 'optparse'
require 'open3'

def create_fresh_output_directory
  outdir_base = 'outdir'
  n = 1
  begin
    outdir = "#{outdir_base}#{n}"
    Dir.mkdir outdir
  rescue Errno::EEXIST
    n += 1
    retry
  end
  outdir
end

op = OptionParser.new
$opt_o = nil
op.def_option('-d DIR', '--output-directory DIR', 'output directory') {|arg| $opt_o = arg }
op.parse(ARGV)

if $opt_o
  outdir = $opt_o
  unless File.directory? outdir
    Dir.mkdir outdir
  end
else
  outdir = create_fresh_output_directory
end

Dir.chdir outdir

nums = Dir["raw*.pnm\0out*.png"].reject {|f|
  /\A(raw|out)([0-9]+)\.(pnm|png)\z/ !~ f
}.map {|f| f[/\d+/].to_i }
if nums.empty?
  start = 0
else
  start = nums.max + 1
end

resolution_dpi = 300 # dot per inch
resolution_dpm = (resolution_dpi / 25.4 * 1000).round # dot per meter
system(
  "scanimage",
  "--batch=raw%04d.pnm",
  "--batch-start=#{start}",
  "--source", "ADF Duplex",
  "--mode", "Color",
  "--resolution", resolution_dpi.to_s,
  "-l", "30",
  "-x", "160",
  "--ald=yes")

fs = Dir["raw*.pnm"].reject {|f| /\Araw([0-9]+)\.pnm\z/ !~ f }
fs = fs.sort_by {|f| f[/\d+/].to_i }

numdigits = fs.last[/\d+/].length
fmt = "out%0#{numdigits}d.png"

Dir["out*.png"].each {|f|
  next if /\Aout([0-9]+)\.png\z/ !~ f
  digits = $1
  if digits.length != numdigits
    nf = fmt % digits.to_i
    File.rename f, nf
  end
}

fs.each {|f|
  n = f[/\d+/].to_i
  of = fmt % n
  tf = of + ".part"
  #angle = n % 2 == 0 ? "-R 270" : "-R 90"
  #system("tiffcrop #{angle} #{f} #{of}")
  angle = n % 2 == 0 ? "-cw" : "-ccw"
  Open3.pipeline(
    ["pnmflip", angle, f],
    ["pnmtopng",
      "-phys", resolution_dpm.to_s, resolution_dpm.to_s, "1",
      "-compression", "9",
      :out => tf])
  File.rename tf, of
  File.delete f
}
