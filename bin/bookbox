#!/usr/bin/env ruby

require_relative '../lib/bookbox'

require 'optparse'
require 'webrick'
require 'erb'

#$opt_image_dir = '.'
$opt_docroot = File.dirname(File.dirname(File.realpath(__FILE__))) + "/docroot"
p $opt_docroot

include ERB::Util


def op_server
  op = OptionParser.new
  op.def_option('-h', '--help', 'show help message') { puts op; exit 0 }
  #op.def_option('-d DIR', '--image-dir DIR', 'image directory (default: ".")') {|arg| $opt_image_dir = arg }
  op
end

module ServletUtil
  def err(req, res, mesg)
    res['content-type'] = 'text/html'
    res.body = "<title>#{h mesg}</title>#{h mesg}"
    nil
  end
end

class TopDirHandler < WEBrick::HTTPServlet::AbstractServlet
  include ServletUtil

  def initialize(server, docroot, im)
    @config = server.config
    @docroot = docroot
    @im = im
  end

  def erb_filter(req, res, content)
    content = content.gsub(/^[ \t]*%/, '%')
    ERB.new(content, nil, '%').result(binding)
  end

  def do_GET(req, res)
    #p [:TopDirHandler, req.path]
    filename = @docroot.dup
    path = req.path
    path = '/index.html' if path == '/'
    path.scan(%r{/([^/]*)}) {
      seg = $1
      return err(req, res, "path contains #{seg.inspect}") if seg == '.' || seg == '..'
      filename << '/' << seg
    }
    return err(req, res, "file not found: #{filename}") unless File.file? filename
    content = File.read(filename)
    case filename
    when /\.html\z/ then res['content-type'] = 'text/html'
    when /\.js\z/ then res['content-type'] = 'text/javascript'
    when /\.css\z/ then res['content-type'] = 'text/css'
    end
    content = erb_filter(req, res, content) if /\A%#erb/ =~ content
    res.body = content
    nil
  end
end

class ImageDirHandler < WEBrick::HTTPServlet::AbstractServlet
  include ServletUtil

  def initialize(server, im)
    @im = im
    @server = server
    @config = server.config
    @image_dir = '.'
  end

  def do_GET(req, res)
    #p [:ImageDirHandler, req.path]
    if req.path == '/i'
      res['content-type'] = 'text/html'
      res.set_redirect(WEBrick::HTTPStatus::MovedPermanently, '/i/')
      return
    end
    if req.path == '/i/'
      res.filename = @image_dir
      WEBrick::HTTPServlet::FileHandler.get_instance(@server, res.filename, :FancyIndexing => true).service(req, res)
      return
    end
    return err(req, res, "unexpected uri: #{req.request_uri}") if %r{\A/i/[^/]+\z} !~ req.path
    basename = req.path.sub(%r{\A.*/}m, '')
    @im.make(basename)
    res.filename = basename
    WEBrick::HTTPServlet::DefaultFileHandler.get_instance(@config, basename).service(req, res)
    nil
  end
end

def main_server(argv)
  op_server.parse(argv)
  im = BookBox::ImageMaker.new
  webrick_config = {
    :DocumentRoot => '/home/username/public_html/',
    :BindAddress => '127.0.0.1',
    :Port => 10080}
  srv = WEBrick::HTTPServer.new(webrick_config)
  url = "http://#{srv[:BindAddress]}:#{srv[:Port]}"
  srv.logger.info url
  trap("INT"){ srv.shutdown }
  trap("TERM"){ srv.shutdown }
  trap("QUIT"){ srv.shutdown }
  srv.mount('', TopDirHandler, $opt_docroot, im)
  #srv.mount('/t', WEBrick::HTTPServlet::FileHandler, File.expand_path($opt_image_dir), :FancyIndexing => true)
  srv.mount('/i/', ImageDirHandler, im)
  srv.start
end

def main(argv)
  subcommand = argv.shift || 'normal'
  case subcommand
  when 'normal'
  when 'server'
    main_server argv
  else
    raise "unexpected subcommand: #{subcommand.inspect}"
  end
end

main ARGV
